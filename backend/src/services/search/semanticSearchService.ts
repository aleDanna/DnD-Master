/**
 * Semantic Search Service
 * T121: Implement SemanticSearchService (pgvector queries)
 * T123: Add fallback logic when embeddings unavailable
 */

import { query as dbQuery } from '../../config/database.js';
import {
  SearchResultItem,
  ContentType,
  ContentCategory,
  SearchResponse,
  CATEGORY_LABELS,
} from '../../types/search.types.js';
import { fullTextSearch } from './fullTextSearchService.js';

interface SemanticSearchOptions {
  query: string;
  categories?: ContentCategory[];
  limit?: number;
  embedding?: number[];
}

interface SearchGroup {
  category: ContentCategory;
  categoryLabel: string;
  items: SearchResultItem[];
  totalCount: number;
}

interface TableConfig {
  name: string;
  type: ContentType;
  category: ContentCategory;
  titleColumn: string;
  snippetColumn: string;
  sourceDocColumn: string;
  sourcePageColumn: string;
}

const TABLE_CONFIGS: TableConfig[] = [
  { name: 'rules', type: 'rule', category: 'rules', titleColumn: 'title', snippetColumn: 'summary', sourceDocColumn: 'source_document', sourcePageColumn: 'source_page' },
  { name: 'classes', type: 'class', category: 'classes', titleColumn: 'name', snippetColumn: 'description', sourceDocColumn: 'source_document', sourcePageColumn: 'source_page' },
  { name: 'races', type: 'race', category: 'races', titleColumn: 'name', snippetColumn: 'description', sourceDocColumn: 'source_document', sourcePageColumn: 'source_page' },
  { name: 'spells', type: 'spell', category: 'spells', titleColumn: 'name', snippetColumn: 'description', sourceDocColumn: 'source_document', sourcePageColumn: 'source_page' },
  { name: 'monsters', type: 'monster', category: 'bestiary', titleColumn: 'name', snippetColumn: 'description', sourceDocColumn: 'source_document', sourcePageColumn: 'source_page' },
  { name: 'items', type: 'item', category: 'items', titleColumn: 'name', snippetColumn: 'description', sourceDocColumn: 'source_document', sourcePageColumn: 'source_page' },
  { name: 'backgrounds', type: 'background', category: 'backgrounds', titleColumn: 'name', snippetColumn: 'description', sourceDocColumn: 'source_document', sourcePageColumn: 'source_page' },
  { name: 'feats', type: 'feat', category: 'feats', titleColumn: 'name', snippetColumn: 'description', sourceDocColumn: 'source_document', sourcePageColumn: 'source_page' },
  { name: 'conditions', type: 'condition', category: 'conditions', titleColumn: 'name', snippetColumn: 'description', sourceDocColumn: 'source_document', sourcePageColumn: 'source_page' },
  { name: 'skills', type: 'skill', category: 'skills', titleColumn: 'name', snippetColumn: 'description', sourceDocColumn: 'source_document', sourcePageColumn: 'source_page' },
];

/**
 * Check if embeddings are available in the database
 */
async function checkEmbeddingsAvailable(): Promise<boolean> {
  try {
    // Check if any table has embeddings populated
    const result = await dbQuery(`
      SELECT EXISTS (
        SELECT 1 FROM rules WHERE embedding IS NOT NULL LIMIT 1
      ) as has_embeddings
    `);
    return result.rows[0]?.has_embeddings || false;
  } catch (error) {
    console.error('Error checking embeddings availability:', error);
    return false;
  }
}

/**
 * Generate embedding for query using external API
 * For now, this returns null - embeddings would be generated by an external service
 */
async function generateQueryEmbedding(query: string): Promise<number[] | null> {
  // In production, this would call OpenAI, Anthropic, or another embedding API
  // For now, we return null to trigger fallback to full-text search

  // Example implementation with OpenAI:
  // const response = await fetch('https://api.openai.com/v1/embeddings', {
  //   method: 'POST',
  //   headers: {
  //     'Content-Type': 'application/json',
  //     'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
  //   },
  //   body: JSON.stringify({
  //     model: 'text-embedding-3-small',
  //     input: query,
  //   }),
  // });
  // const data = await response.json();
  // return data.data[0].embedding;

  console.log(`[SemanticSearch] Would generate embedding for: "${query}"`);
  return null;
}

/**
 * Perform semantic search across all content tables using pgvector
 */
export async function semanticSearch(options: SemanticSearchOptions): Promise<SearchResponse> {
  const { query, categories, limit = 50, embedding } = options;

  if (!query.trim()) {
    return {
      query,
      mode: 'semantic',
      totalResults: 0,
      groups: [],
    };
  }

  // Check if embeddings are available
  const hasEmbeddings = await checkEmbeddingsAvailable();

  if (!hasEmbeddings) {
    console.log('[SemanticSearch] Embeddings not available, falling back to full-text search');
    return fallbackToFullText(query, categories, limit);
  }

  // Get query embedding (from provided or generate new)
  let queryEmbedding = embedding;
  if (!queryEmbedding) {
    queryEmbedding = await generateQueryEmbedding(query);
  }

  if (!queryEmbedding) {
    console.log('[SemanticSearch] Could not generate embedding, falling back to full-text search');
    return fallbackToFullText(query, categories, limit);
  }

  // Perform vector search
  const searchTables = getSearchTables(categories);
  const allResults: SearchResultItem[] = [];

  const searchPromises = searchTables.map(table =>
    searchTableSemantic(table, queryEmbedding!, limit)
  );

  const tableResults = await Promise.all(searchPromises);

  for (const results of tableResults) {
    allResults.push(...results);
  }

  // Sort by similarity (rank = 1 - distance, so higher is better)
  allResults.sort((a, b) => b.rank - a.rank);

  // Filter out low-similarity results (threshold)
  const minSimilarity = 0.5;
  const filteredResults = allResults.filter(r => r.rank >= minSimilarity);

  // Group results by category
  const groups = groupResultsByCategory(filteredResults.slice(0, limit));

  return {
    query,
    mode: 'semantic',
    totalResults: filteredResults.length,
    groups,
  };
}

async function searchTableSemantic(
  config: TableConfig,
  embedding: number[],
  limit: number
): Promise<SearchResultItem[]> {
  // Convert embedding to pgvector format
  const embeddingStr = `[${embedding.join(',')}]`;

  const sqlQuery = `
    SELECT
      id,
      ${config.titleColumn} as title,
      slug,
      COALESCE(${config.snippetColumn}, '') as snippet,
      ${config.sourceDocColumn} as source_document,
      ${config.sourcePageColumn} as source_page,
      1 - (embedding <=> $1::vector) as similarity
    FROM ${config.name}
    WHERE embedding IS NOT NULL
    ORDER BY embedding <=> $1::vector
    LIMIT $2
  `;

  try {
    const result = await dbQuery(sqlQuery, [embeddingStr, limit]);

    return result.rows.map(row => ({
      id: row.id,
      type: config.type,
      title: row.title,
      slug: row.slug,
      category: config.category,
      snippet: truncateSnippet(row.snippet, 150),
      rank: parseFloat(row.similarity) || 0,
      source: {
        document: row.source_document,
        page: row.source_page,
      },
    }));
  } catch (error) {
    console.error(`Error performing semantic search on ${config.name}:`, error);
    return [];
  }
}

function getSearchTables(categories?: ContentCategory[]): TableConfig[] {
  if (!categories || categories.length === 0) {
    return TABLE_CONFIGS;
  }
  return TABLE_CONFIGS.filter(config => categories.includes(config.category));
}

function truncateSnippet(text: string, maxLength: number): string {
  if (!text) return '';
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength).replace(/\s+\S*$/, '') + '...';
}

function groupResultsByCategory(results: SearchResultItem[]): SearchGroup[] {
  const groupMap = new Map<ContentCategory, SearchResultItem[]>();

  for (const result of results) {
    const existing = groupMap.get(result.category) || [];
    existing.push(result);
    groupMap.set(result.category, existing);
  }

  const groups: SearchGroup[] = [];

  for (const [category, items] of groupMap.entries()) {
    groups.push({
      category,
      categoryLabel: CATEGORY_LABELS[category],
      items,
      totalCount: items.length,
    });
  }

  groups.sort((a, b) => b.totalCount - a.totalCount);

  return groups;
}

/**
 * Fallback to full-text search when semantic search is not available
 */
async function fallbackToFullText(
  query: string,
  categories?: ContentCategory[],
  limit?: number
): Promise<SearchResponse> {
  const result = await fullTextSearch({ query, categories, limit });
  // Mark as semantic mode but indicate fallback happened
  return {
    ...result,
    mode: 'semantic',
    suggestions: ['Semantic search is not yet configured. Using keyword search.'],
  };
}

export default {
  semanticSearch,
  checkEmbeddingsAvailable,
  generateQueryEmbedding,
};
