/**
 * Event Repository
 * Handles all database operations for game events (session log)
 */

import { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '../../models/database.types.js';
import type { GameEvent, CreateEventInput, EventType, EventContent } from '../../models/event.js';

type DbClient = SupabaseClient<Database>;

export class EventRepository {
  constructor(private client: DbClient) {}

  /**
   * Create a new event
   * Sequence number is auto-generated by the database trigger
   */
  async create(input: CreateEventInput): Promise<GameEvent> {
    const { data, error } = await this.client
      .from('events')
      .insert({
        session_id: input.session_id,
        type: input.type,
        actor_id: input.actor_id || null,
        actor_name: input.actor_name || null,
        content: JSON.parse(JSON.stringify(input.content)),
        rule_citations: input.rule_citations
          ? JSON.parse(JSON.stringify(input.rule_citations))
          : [],
        // sequence is auto-generated
      })
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to create event: ${error.message}`);
    }

    return this.mapToEvent(data);
  }

  /**
   * Get an event by ID
   */
  async getById(id: string): Promise<GameEvent | null> {
    const { data, error } = await this.client
      .from('events')
      .select('*')
      .eq('id', id)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null;
      throw new Error(`Failed to get event: ${error.message}`);
    }

    return this.mapToEvent(data);
  }

  /**
   * List events for a session (paginated)
   */
  async listBySession(
    sessionId: string,
    options: {
      limit?: number;
      afterSequence?: number;
      beforeSequence?: number;
      types?: EventType[];
    } = {}
  ): Promise<GameEvent[]> {
    const { limit = 50, afterSequence, beforeSequence, types } = options;

    let query = this.client
      .from('events')
      .select('*')
      .eq('session_id', sessionId)
      .order('sequence', { ascending: true })
      .limit(limit);

    if (afterSequence !== undefined) {
      query = query.gt('sequence', afterSequence);
    }

    if (beforeSequence !== undefined) {
      query = query.lt('sequence', beforeSequence);
    }

    if (types && types.length > 0) {
      query = query.in('type', types);
    }

    const { data, error } = await query;

    if (error) {
      throw new Error(`Failed to list events: ${error.message}`);
    }

    return (data || []).map(this.mapToEvent);
  }

  /**
   * Get recent events for a session (for AI context)
   */
  async getRecentEvents(sessionId: string, count = 20): Promise<GameEvent[]> {
    const { data, error } = await this.client
      .from('events')
      .select('*')
      .eq('session_id', sessionId)
      .order('sequence', { ascending: false })
      .limit(count);

    if (error) {
      throw new Error(`Failed to get recent events: ${error.message}`);
    }

    // Reverse to get chronological order
    return (data || []).reverse().map(this.mapToEvent);
  }

  /**
   * Get the latest event sequence number for a session
   */
  async getLatestSequence(sessionId: string): Promise<number> {
    const { data, error } = await this.client
      .from('events')
      .select('sequence')
      .eq('session_id', sessionId)
      .order('sequence', { ascending: false })
      .limit(1)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return 0;
      throw new Error(`Failed to get latest sequence: ${error.message}`);
    }

    return data?.sequence || 0;
  }

  /**
   * Get events by type
   */
  async getByType(sessionId: string, type: EventType): Promise<GameEvent[]> {
    const { data, error } = await this.client
      .from('events')
      .select('*')
      .eq('session_id', sessionId)
      .eq('type', type)
      .order('sequence', { ascending: true });

    if (error) {
      throw new Error(`Failed to get events by type: ${error.message}`);
    }

    return (data || []).map(this.mapToEvent);
  }

  /**
   * Get all dice roll events for a session
   */
  async getDiceRolls(sessionId: string): Promise<GameEvent[]> {
    return this.getByType(sessionId, 'dice_roll');
  }

  /**
   * Get event count for a session
   */
  async getEventCount(sessionId: string): Promise<number> {
    const { count, error } = await this.client
      .from('events')
      .select('*', { count: 'exact', head: true })
      .eq('session_id', sessionId);

    if (error) {
      throw new Error(`Failed to count events: ${error.message}`);
    }

    return count || 0;
  }

  /**
   * Delete all events for a session
   */
  async deleteBySession(sessionId: string): Promise<void> {
    const { error } = await this.client.from('events').delete().eq('session_id', sessionId);

    if (error) {
      throw new Error(`Failed to delete events: ${error.message}`);
    }
  }

  /**
   * Create a player action event
   */
  async createPlayerAction(
    sessionId: string,
    actorId: string,
    actorName: string,
    text: string,
    characterId?: string
  ): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'player_action',
      actor_id: actorId,
      actor_name: actorName,
      content: { text, character_id: characterId },
    });
  }

  /**
   * Create an AI response event
   */
  async createAIResponse(
    sessionId: string,
    narrative: string,
    mechanics?: string,
    stateChanges?: Array<{
      type: string;
      target?: string;
      value?: number | string;
      description: string;
    }>,
    ruleCitations?: Array<{
      rule_id: string;
      title: string;
      source: string;
      excerpt?: string;
    }>
  ): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'ai_response',
      actor_name: 'Dungeon Master',
      content: {
        narrative,
        mechanics,
        state_changes: stateChanges,
      },
      rule_citations: ruleCitations,
    });
  }

  /**
   * Create a dice roll event
   */
  async createDiceRoll(
    sessionId: string,
    actorId: string,
    actorName: string,
    dice: string,
    reason: string,
    individualRolls: number[],
    modifier: number,
    total: number,
    mode: 'rng' | 'player_entered'
  ): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'dice_roll',
      actor_id: actorId,
      actor_name: actorName,
      content: {
        dice,
        reason,
        individual_rolls: individualRolls,
        modifier,
        total,
        mode,
        roller_name: actorName,
      },
    });
  }

  /**
   * Create a session start event
   */
  async createSessionStart(sessionId: string): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'session_start',
      content: { timestamp: new Date().toISOString() },
    });
  }

  /**
   * Create a session end event
   */
  async createSessionEnd(sessionId: string, summary?: string): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'session_end',
      content: { timestamp: new Date().toISOString(), summary },
    });
  }

  /**
   * Map database row to GameEvent type
   */
  private mapToEvent(data: Database['public']['Tables']['events']['Row']): GameEvent {
    return {
      id: data.id,
      session_id: data.session_id,
      type: data.type as EventType,
      actor_id: data.actor_id,
      actor_name: data.actor_name,
      content: data.content as EventContent,
      rule_citations: (data.rule_citations as GameEvent['rule_citations']) || [],
      sequence: data.sequence,
      created_at: data.created_at,
    };
  }
}

/**
 * Factory function to create an event repository
 */
export function createEventRepository(client: DbClient): EventRepository {
  return new EventRepository(client);
}
