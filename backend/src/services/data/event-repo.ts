/**
 * Event Repository
 * Handles all database operations for game events (session log)
 */

import { query, DbClient } from '../../config/database.js';
import type { EventRow, EventType as DbEventType } from '../../models/database.types.js';
import type { GameEvent, CreateEventInput, EventType, EventContent } from '../../models/event.js';

export class EventRepository {
  constructor(private client?: DbClient) {}

  private async executeQuery<T>(text: string, params?: any[]): Promise<{ rows: T[]; rowCount: number }> {
    if (this.client) {
      return this.client.query<T>(text, params);
    }
    return query<T>(text, params);
  }

  /**
   * Create a new event
   * Sequence number is auto-generated by the database trigger or manually calculated
   */
  async create(input: CreateEventInput): Promise<GameEvent> {
    // Get the next sequence number
    const seqResult = await this.executeQuery<{ max_seq: number }>(
      'SELECT COALESCE(MAX(sequence), 0) + 1 as max_seq FROM events WHERE session_id = $1',
      [input.session_id]
    );
    const nextSequence = seqResult.rows[0]?.max_seq || 1;

    const result = await this.executeQuery<EventRow>(
      `INSERT INTO events (session_id, type, actor_id, actor_name, content, rule_citations, sequence)
       VALUES ($1, $2, $3, $4, $5, $6, $7)
       RETURNING *`,
      [
        input.session_id,
        input.type,
        input.actor_id || null,
        input.actor_name || null,
        JSON.stringify(input.content),
        JSON.stringify(input.rule_citations || []),
        nextSequence,
      ]
    );

    if (result.rowCount === 0) {
      throw new Error('Failed to create event');
    }

    return this.mapToEvent(result.rows[0]);
  }

  /**
   * Get an event by ID
   */
  async getById(id: string): Promise<GameEvent | null> {
    const result = await this.executeQuery<EventRow>(
      'SELECT * FROM events WHERE id = $1',
      [id]
    );

    if (result.rowCount === 0) {
      return null;
    }

    return this.mapToEvent(result.rows[0]);
  }

  /**
   * List events for a session (paginated)
   */
  async listBySession(
    sessionId: string,
    options: {
      limit?: number;
      afterSequence?: number;
      beforeSequence?: number;
      types?: EventType[];
    } = {}
  ): Promise<GameEvent[]> {
    const { limit = 50, afterSequence, beforeSequence, types } = options;

    let queryText = 'SELECT * FROM events WHERE session_id = $1';
    const params: any[] = [sessionId];
    let paramIndex = 2;

    if (afterSequence !== undefined) {
      queryText += ` AND sequence > $${paramIndex}`;
      params.push(afterSequence);
      paramIndex++;
    }

    if (beforeSequence !== undefined) {
      queryText += ` AND sequence < $${paramIndex}`;
      params.push(beforeSequence);
      paramIndex++;
    }

    if (types && types.length > 0) {
      queryText += ` AND type = ANY($${paramIndex})`;
      params.push(types);
      paramIndex++;
    }

    queryText += ` ORDER BY sequence ASC LIMIT $${paramIndex}`;
    params.push(limit);

    const result = await this.executeQuery<EventRow>(queryText, params);

    return result.rows.map(this.mapToEvent);
  }

  /**
   * Get recent events for a session (for AI context)
   */
  async getRecentEvents(sessionId: string, count = 20): Promise<GameEvent[]> {
    const result = await this.executeQuery<EventRow>(
      'SELECT * FROM events WHERE session_id = $1 ORDER BY sequence DESC LIMIT $2',
      [sessionId, count]
    );

    // Reverse to get chronological order
    return result.rows.reverse().map(this.mapToEvent);
  }

  /**
   * Get the latest event sequence number for a session
   */
  async getLatestSequence(sessionId: string): Promise<number> {
    const result = await this.executeQuery<{ sequence: number }>(
      'SELECT sequence FROM events WHERE session_id = $1 ORDER BY sequence DESC LIMIT 1',
      [sessionId]
    );

    return result.rows[0]?.sequence || 0;
  }

  /**
   * Get events by type
   */
  async getByType(sessionId: string, type: EventType): Promise<GameEvent[]> {
    const result = await this.executeQuery<EventRow>(
      'SELECT * FROM events WHERE session_id = $1 AND type = $2 ORDER BY sequence ASC',
      [sessionId, type]
    );

    return result.rows.map(this.mapToEvent);
  }

  /**
   * Get all dice roll events for a session
   */
  async getDiceRolls(sessionId: string): Promise<GameEvent[]> {
    return this.getByType(sessionId, 'dice_roll');
  }

  /**
   * Get event count for a session
   */
  async getEventCount(sessionId: string): Promise<number> {
    const result = await this.executeQuery<{ count: string }>(
      'SELECT COUNT(*) as count FROM events WHERE session_id = $1',
      [sessionId]
    );

    return parseInt(result.rows[0]?.count || '0', 10);
  }

  /**
   * Delete all events for a session
   */
  async deleteBySession(sessionId: string): Promise<void> {
    await this.executeQuery(
      'DELETE FROM events WHERE session_id = $1',
      [sessionId]
    );
  }

  /**
   * Create a player action event
   */
  async createPlayerAction(
    sessionId: string,
    actorId: string,
    actorName: string,
    text: string,
    characterId?: string
  ): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'player_action',
      actor_id: actorId,
      actor_name: actorName,
      content: { text, character_id: characterId },
    });
  }

  /**
   * Create an AI response event
   */
  async createAIResponse(
    sessionId: string,
    narrative: string,
    mechanics?: string,
    stateChanges?: Array<{
      type: string;
      target?: string;
      value?: number | string;
      description: string;
    }>,
    ruleCitations?: Array<{
      rule_id: string;
      title: string;
      source: string;
      excerpt?: string;
    }>
  ): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'ai_response',
      actor_name: 'Dungeon Master',
      content: {
        narrative,
        mechanics,
        state_changes: stateChanges,
      },
      rule_citations: ruleCitations,
    });
  }

  /**
   * Create a dice roll event
   */
  async createDiceRoll(
    sessionId: string,
    actorId: string,
    actorName: string,
    dice: string,
    reason: string,
    individualRolls: number[],
    modifier: number,
    total: number,
    mode: 'rng' | 'player_entered'
  ): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'dice_roll',
      actor_id: actorId,
      actor_name: actorName,
      content: {
        dice,
        reason,
        individual_rolls: individualRolls,
        modifier,
        total,
        mode,
        roller_name: actorName,
      },
    });
  }

  /**
   * Create a session start event
   */
  async createSessionStart(sessionId: string): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'session_start',
      content: { timestamp: new Date().toISOString() },
    });
  }

  /**
   * Create a session end event
   */
  async createSessionEnd(sessionId: string, summary?: string): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'session_end',
      content: { timestamp: new Date().toISOString(), summary },
    });
  }

  /**
   * Create a session save event
   */
  async createSessionSave(sessionId: string, summary: string): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'session_save',
      content: { timestamp: new Date().toISOString(), summary },
    });
  }

  /**
   * Create a session resume event
   */
  async createSessionResume(sessionId: string): Promise<GameEvent> {
    return this.create({
      session_id: sessionId,
      type: 'session_resume',
      content: { timestamp: new Date().toISOString() },
    });
  }

  /**
   * Map database row to GameEvent type
   */
  private mapToEvent(data: EventRow): GameEvent {
    return {
      id: data.id,
      session_id: data.session_id,
      type: data.type as EventType,
      actor_id: data.actor_id,
      actor_name: data.actor_name,
      content: (typeof data.content === 'string' ? JSON.parse(data.content) : data.content) as EventContent,
      rule_citations: (typeof data.rule_citations === 'string' ? JSON.parse(data.rule_citations) : data.rule_citations) || [],
      sequence: data.sequence,
      created_at: data.created_at,
    };
  }
}

/**
 * Factory function to create an event repository
 */
export function createEventRepository(client?: DbClient): EventRepository {
  return new EventRepository(client);
}
